OPEN Chain Yellow Paper\
î¿¿

[Consensus  5](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.rrwcet6bgohi)

[Block Production  6](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.hxg7objeecno)

[Genesis Block Production  7](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.wq31pp2iclkj)

[Main Block Production  7](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.72gctcfibc09)

[Block Validation  8](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.h8s9itjbmtlw)

[Parameters  9](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.4kwqpzg32d2m)

[Voting  10](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.flmez27bjs6d)

[Core  12](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.xfzpnffozv1t)

[Models  12](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.6lkuo2lsrt3p)

[Temporary  12](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.dzreux8rl0yf)

[Permanent  13](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.kqobh3pbighm)

[Transactions  13](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.yyzofrm61z3x)

[Blocks  13](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.w88q952tosdu)

[Contract  14](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.bu9190giynsx)

[Receipts  14](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.gm3bz2qmqcep)

[State  15](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.1co11u1cfdbj)

[Store Synchronisation  15](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.tz37f8pytn15)

[Sync Messages  16](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.rz62kpl39kwp)

[Step of synchronization  16](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.o0g783sz8uek)

[Init  16](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.7r2gxf30jxpf)

[Epoch Synchronization  17](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.stnymw4i4ku3)

[DB checker  18](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.a1o0czn2m8ji)

[Prepare DB  18](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.31te2iesba5l)

[Delete invalid chain part  18](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.8m3j5b1oyh9b)

[Cryptography  19](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.i6hqbokj163s)

[Bitcoin Improvement Proposal  19](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.7gd2jdy8pius)

[BIP32 (Hierarchical Deterministic Wallets)  19](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.iyvqcl9mmjuo)

[BIP39 (Mnemonic code for generating deterministic keys)  20](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.nb2slm55njr)

[Asymmetric cryptography  22](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.ypic4vzgflqy)

[Elliptic-curve cryptography  22](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.9lr60pyp21o5)

[Private and public keys generation  23](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.3md9krddqiht)

[Digital signature  23](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.vui4869tm7so)

[Signing transaction  23](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.aed02lkuh55y)

[Signing Block  24](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.74gjcu9kzfnf)

[Hash Functions  25](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.p3d566j3lm4)

[Merkle Root  26](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.5gg5qxzbv2xn)

[Network  28](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.2nahcd3fqd16)

[Serialization protocol  28](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.jwfobi6t0z2b)

[Message header  28](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.hnpta8ro2jo0)

[Message body  28](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.mfet0cwbby3n)

[Gossip Protocol  29](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.dqsrpny9bmxe)

[Time Synchronisation  30](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.7ldwqt42plds)

[Smart Contract  31](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.9o7fdhx7ngfa)

[Creation  31](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.yi6kj5i0o8l1)

[Writing a contract  31](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.du0lfcyzxosg)

[Validation  31](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.gl5oldakc96u)

[Evaluation  33](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.hv9e1n4l42y7)

[Loading  33](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.a09k1pvjlxqx)

[Execution  33](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.fmexnirana3n)

[State Synchronisation  34](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.q6j2juvertq5)

[Remote Procedure Call  35](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.lppuw5otzp1c)

[Get info  37](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.f2l78m6i26ay)

[Get version  38](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.kke78hlqnc9l)

[Get uptime  38](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.buow7oyq8262)

[Get hardware info  39](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.3oqucrw4v9gz)

[Get blockchain info  41](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.aw7smql1lwpf)

[Do generate  42](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.u0bqqjfccf9n)

[Do restore  44](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.yjurh4p8x83s)

[Get wallet balance  45](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.sg0mxgk1xoin)

[Get wallet votes for delegates  46](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.2ta2ndh08qew)

[Validate address  47](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.rqkabzhv7ja5)

[Do derive  48](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.22m37ehhjrxq)

[Do private import  50](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.abuv6xmh0xuj)

[Extended import  51](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.xy9co88ft76b)

[Do key import in WIF format  52](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.f7hcplfo8a6z)

[Get all of genesis blocks  53](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.fb5fzm1umgz)

[Get genesis block  54](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.yqb4ej9ddee5)

[Get previous genesis block  55](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.4cu599idzg01)

[Get next genesis block  55](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.3zrnf7pflq8a)

[Get all of main blocks  56](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.bcb6maoehikv)

[Get main block  58](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.la11qqb1haez)

[Get previous main block  59](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.n47ryd6oq7mh)

[Get next main block  60](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.4jojidvgk1q7)

[Send delegate transaction  61](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.8tbmna8mh3rk)

[Get delegate transaction  63](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.210g2teh2lqo)

[Get all of reward transactions  64](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.edw9tv1ia2d)

[Get reward transaction  65](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.w45alae18qso)

[Get all transfer transactions  66](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.7ar8ydc5x4oy)[

[Send transfer transaction  68](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.5y08dqt6l7fv)

[Get transfer transaction by hash  70](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.urpks8rj28dr)

[Get transfer transaction by address  71](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.m51ssq4lvbgo)

[Send vote transaction  72](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.80l00atsbdqi)

[Get vote transaction  74](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.6xpl9iice6fp)

[Get delegates  75](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.u723l86nc594)

[Get active delegates  76](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.m3b002niq57z)

[Get delegates view  77](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.cya2szvgdcy2)

[Get receipt  79](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.2pxu3fkhlmca)

[Get cost of execution/deployment of the contract  81](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.e34qec79a02d)î¿¾

|

Topic

 |

Author

 |
|

Consensus: Block Production

 |

Gerard

 |
|

Consensus: Block Validation

 |

Gerard

 |
|

Consensus: Voting

 |

Gerard

 |
|

Consensus: Parameters (block capacity, epoch duration...)

 |

Gerard

 |
|

Core: Store

 |

Evleev

 |
|

Core: Store Synchronisation

 |

Evleev

 |
|

Crypto: BIP39

 |

Anna Shunko

 |
|

Crypto: BIP42

 |

Anna Shunko

 |
|

Crypto: Merkle Root

 |

Anna Shunko

 |
|

Crypto: Sign

 |

Anna Shunko

 |
|

Network: Gossip Protocol

 |

Gerard

 |
|

Network: Serialisation Protocol

 |

Gerard

 |
|

Network: Time Synchronisation

 |

Evleev

 |
|

Smart Contract: Creation

 |

Yauheni Efimenko

 |
|

Smart Contract: Validation

 |

Yauheni Efimenko

 |
|

Smart Contract: Evaluation

 |

Evleev

 |
|

Smart Contract: Loading

 |

Yauheni Efimenko

 |
|

Smart Contract: Execution

 |

Evleev

 |
|

Smart Contract: State Synchronisation

 |

Evleev

 |
|

RPC: Health Checking endpoints

 |

Eliseenko, Shakhau

 |
|

RPC: Explorer endpoints

 |

Eliseenko, Shakhau

 |
|

RPC: Client endpoints

 |

Eliseenko, Shakhau

 |

Consensus
=========

Open chain consensus designs a DPoS and BFT based.

In OPEN consensus N nodes are elected as Active Delegates each Epoch. An Epoch is a predetermined interval (e.g. 21 blocks) during which the Active Delegates set is fixed. Each Epoch divides by Timeslots. Number of Timeslots can be various, depends on how many Timeslots needs to reach the necessary blocks amount. For each Timeslot, Timeslot-Leader is defined. Timeslot-Leader is one of the Active Delegates. Timeslot-Leader produces the block, the rest of the Active Delegates become validators. Each Timeslot involves five major phases:

-   PREPARE - defining a timeslot-leader, the block production, block broadcasting

-   PREVOTE - when node received the block, than send signed pre-vote message

-   COMMIT - Â when node received â Â from active delegates total count pre-vote messages, than validate the block and send signed commit message

-   SAVE - when node received â from active delegates total count commit messages, than save the block

-   IDLE - when in intermission (block processing of current timeslot is finished but next timeslot is not started yet.). Time for chain synchronization

PREPARE stage:

![](https://docs.google.com/drawings/u/2/d/sE3oecrcKr5ICG_uc_Ffqyg/image?w=433&h=335&rev=43&ac=1&parent=1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs)

PREVOTE stage

![](https://docs.google.com/drawings/u/2/d/s9Jr1Y_9NcuTPWnNlAGnY7g/image?w=479&h=292&rev=8&ac=1&parent=1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs)

COMMIT stage

![](https://docs.google.com/drawings/u/2/d/sV9EUbk29bcd7Dr-VrVqyJA/image?w=495&h=342&rev=27&ac=1&parent=1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs)

Block Production
----------------

Node has a scheduled job. It is invoked each time, when timeslot number has changed. Timeslot duration is 18 seconds. Timeslot calculation is based on timestamp, when current epoch started.

Example: consider epoch started at timestamp, equal to 38, current timestamp is 51, timeslot duration is 5 seconds. To calculate, when timeslot will change, the next calculation should be executed:

Timeslottime left = Timeslotduration - ((Epochstart - Timestamp) % Timeslotduration)

e.g. 5 - ((51 - 38) % 5) = 2

Timeslot change triggers job, checking sync status of clock and chain. In case one of them not synchronized, block creation won't happen.

![](https://docs.google.com/drawings/u/2/d/sF_vHyILfRdHeEqszp-mkeA/image?w=624&h=192&rev=2&ac=1&parent=1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs)

### Genesis Block Production

Genesis block is produced in case epoch contains sufficient amount of Main blocks. Genesis block is announcing next epoch rules. In the current implementation, it defines a set of Active Delegates. Besides Active delegates list Genesis Block also includes Genesis Nodes list. Genesis nodes need to support the consensus execution in case Active Delegates are failed. Genesis block doesn't contain transactions and is produced by each peer themselves. According to confirmed delegate and vote transactions, each node will get set of active delegates for the next epoch, pack into genesis block and save to storage. When Genesis blocks have the same height throughout the whole network, it's a proof of consensus mechanism stability.

### Main Block Production

Main block is creating by current Timeslot-Leader. If node owns current timeslot, it proceeds block production and broadcasts created block. Block has 6 seconds to be created and spread to active delegates. The rest 12 seconds dedicated to voting and in some cases synchronization process.

Main block packed with unlimited amount of vote and delegate transactions plus up to 1000 transfer transactions. Also block producer creates one more transaction to reflect reward for creation with fixed amount. All transactions are processed, resulting set of receipts and states.

State describes wallet's actual balance at the moment of creation of block, linked to it. Receipt is a result of transaction execution: transaction actually may trigger transfer to multiple wallets, in case there is contract, which splits incoming amount among beneficiaries. Based on transactions, states and receipts, node creates an appropriate merkle hash, which are used to form block's hash. At the end, block hash is signed and node's public key is attached to block to provide other active delegates possibility to validate signature.

As for production order, it is specified in genesis block: from the most voted delegate to the least one. There could be situations, when delegate has not produced block in it's timeslot. Such case is crucial, as epoch should contain exactly 21 main blocks. There is another threat, that more than 34% of all active delegates may become unavailable. To consider such cases, to each set of active delegates, set of boot nodes is attached, so if one of delegates failed production, boot node will produce missing block.

Block Validation
----------------

Those Active Delegates that not participate in block creation, validate block.

It have to receive three types of messages from network to validate and add block to it's chain:

-   PendingBlockMessage - describes information about block's content for validation. Contains the same content as a block entity

-   BlockApprovalMessage - message about node's transition into either PREPARE or COMMIT stages. It contains following fields

-   stageId - digit stage identifier (2 for PREPARE stage, 3 for COMMIT stage)

-   hash - block's hash, which were validated

-   publicKey - delegate's key, which sent message

-   signature - proof that message created by valid delegate

Block validation executed once node accepted incoming block. Active delegate ensures in next statements, regarding incoming block:

-   Block created by current timeslot owner

-   Transactions merkle root is valid

-   States merkle root is valid

-   Receipts merkle root is valid

-   Reward transaction is created correctly

-   Transactions are valid

-   Resulted receipts and states are the same, comparing to message's one

If validation is passed successfully, node considers such block as valid candidate, ready to be stored. But before that, node should accumulate specific number of BlockApprovalMessages:

-   34% from active delegates count of PREPARE messages

-   67% from active delegates count of COMMIT messages

When node accumulated sufficient amount of COMMIT messages, block is persisted to storage

There could be cases, when block in specific timeslot is not valid for local chain. But node still tracks invalid block, as if it will collect required amount of COMMIT messages, node will proceed chain synchronization.

Comparing to active delegates, other network participants broadcast blocks further and collect only commit messages, which means, that it does not perform validation and stage transition publishing.

Parameters
----------

Below table describes parameters, used for consensus mechanism

|

Name

 |

Value

 |

Description

 |
|

epochHeight

 |

21

 |

Count of main blocks in single epoch. Reaching it's value means that next block should be genesis one, which will start new epoch

 |
|

delegatesCount

 |

21

 |

Count of active delegates in epoch, should be fetched with rating order

 |
|

blockCapacity

 |

1000

 |

Maximum amount of transfer transactions to pack in main block

 |
|

timeSlotDuration

 |

6000

 |

Amount of time to create block and broadcast it to network

 |
|

timeSlotInterval

 |

12000

 |

Amount of time to reach consensus and sync local storage

 |
|

genesisAddress

 |

0x0000000000000000000000000000000000000000

 |

Address of genesis account, which is sender of fixed reward for block creation

 |
|

rewardBlock

 |

10

 |

Amount of reward for block production

 |
|

feeVoteTxFor

 |

3

 |

Fee for creation of vote transaction

 |
|

feeVoteTxAgainst

 |

1

 |

Fee for recall of vote transaction

 |
|

feeDelegateTx

 |

3

 |

Fee for creation of delegate transaction

 |
|

amountDelegateTx

 |

10

 |

Amount for creation of delegate transaction

 |

Voting
------

All node can existed in three states: Peer, Delegate, Active Delegate.

-   Peer - node with minimal influence in the Consensus reaching process. Can store not complete ledger (light synchronization)

-   Delegate - trusted node with full ledger

-   Active Delegate - active delegate that elected as one of block producers for a specific epoch

To ensure decentralization of the network, participants who want to become block producers, have to become Delegate and stakeholders can vote for the delegates, where their voting weight depends on the size of their stake.

To become a Delegate, Peer should initiate Delegate-Transaction. Delegate-Transaction is bonding specific Node with a specific Wallet. Each Peer can be bonded with only one Wallet. But one Wallet can be bonded with a lot of Peers. Wallets can vote for delegates as well as recall their votes. Each Delegate has its rating which is calculated as a sum of the weights of votes in its favor.

Each wallet has only one vote, which could be given to specific delegate. It is possible to choose only one delegate, then recall vote back and choose another delegate. Vote transaction costs fixed amount of tokens. Votes are considered on genesis blocks creation, where each node fetches from it's local storage delegates, ordered by their rating. Order is preserved in genesis block, meaning that first block created by the most voted delegate and decreasing.

Voting mechanism implements by transmitting Vote-Transaction.

![](https://docs.google.com/drawings/u/2/d/sumscD8iKSnBzL3oNlNLK5w/image?w=624&h=115&rev=66&ac=1&parent=1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs)

Core
====

This package contains business logic and represents a set of rules, principles, and behavior dependencies of domain objects. This layer consists of business models that are represented by domain entities, services that implement the business logic, such as validation of models, repositories designed to transfer business models between the database and the application.

Business entities are stored in an H2 database, this vendor was selected based on the next requirements:

1.  Ease of use for the user, no need for additional settings;

2.  Support embedded mode;

3.  Support in-memory table;

4.  Support transaction;

5.  Support ACID;

6.  Support Hash index;

7.  Fast queries executing;

8.  Small size DB file.

Models
------

Models are a representation of concepts from the subject area, which are represented as temporary, permanent and metadata.

### Temporary

These data are represented by unconfirmed transactions that have not been processed and stored in the ledger. It's transactions are the source for creating blocks and stored in the in-memory table until it gets into a block.

In application existed three type of unconfirmed transaction:

UnconfirmedTransferTransaction

-   Amount

-   Recipient Address

-   Data - field for deploy Smart Contract

UnconfirmedDelegateTransaction

-   Delegate address

-   Amount

UnconfirmedVoteTransaction

-   Delegate address

-   Vote type

### Permanent

The models that present a ledger. It's based on transactions packed into blocks for convenience of work and validation with it.

#### Transactions

A transaction is a signed data package that is put in blocks. There are four types of transactions:

-   TransferTransaction - transfer currency or deploy a smart contract

-   DelegateTransaction - becoming a delegate

-   RewardTransaction - the reward for creating a block

-   VoteTransaction - vote for or against the delegate

All Transactions consist of:

-   Timestamp

-   Fee

-   Sender address

-   Hash

-   Signature

-   Public key

-   Payload

Transactions differ in payload, which is specific to each transaction

-   TransferTransactionPayload

-   Amount

-   Recipient Address

-   Data - field for deploy Smart Contract

-   DelegateTransactionPayload

-   Delegate address

-   Amount

-   RewardTransactionPayload

-   Wallet address

-   Reward

-   VoteTransactionPayload

-   Delegate address

-   Vote type

#### Blocks

A block is a collective entity for various transactions, which is used to simplify processing of transactions. Existed two types of blocks: GenesisBlock is created before each epoch and service for determination delegates on it's epoch, MainBlock is created by the active delegate and represents a container for processed transactions and meta-information for them. Blocks differ in payload:

-   GenesisBlockPayload

-   MainBlockPayload.

Block consist of:

-   Timestamp

-   Height

-   Previous Hash

-   Hash

-   Signature

-   Public Key

-   Payload

GenesisBlockPayload consist of:

-   Epoch Index

-   Active Delegates - List of active delegates for this epoch

MainBlockPayload, payload consist of:

-   Reward Transaction

-   Vote Transactions

-   Delegate Transactions

-   Transfer Transactions

-   Delegate States

-   Account States

-   Receipts

-   Transaction Merkle Hash

-   State Merkle Hash

-   Receipt Merkle Hash

Separate merkle hashes for transactions, receipts and states are allowed exactly defines block content.

#### Contract

The entity required to store smart contract information in the application. It contains source code of the contract in a binary form, it loads to JVM for execution. Also contains the address of owner, self-address use to call the contract by address , cost price for execution, abi - interface smart contract describing the methods available.

### Receipts

Receipt refers to a transaction and contains transaction status and all changes which it produces. Receipts are stored in an appropriate block. Receipt contains:

-   Transaction hash

-   Block

-   Set of transaction results

Transaction result contains:

-   From

-   To

-   Amount

-   Data

-   Error

Simple transfer transaction has two results. The first is the coin transfer between sender and receiver. The second one is fee transfer between sender and block producer. Field Data served for additional information like address smart-contract.

### State

Transactions execution provoke state transitions. State transitions are based on receipts. For each account, only one final state can be generated per block. States are stored in an appropriate block. So, the last state of account is the most actual and confirmed.

State contains common fields:

-   Address

-   Block Id

AccountState contains:

-   Balance

-   Vote for

-   Storage - it is a serialized state of a smart contract

DelegateState contains:

-   Rating

-   Wallet Address

-   Create Date

Store Synchronisation
---------------------

Synchronization of store occur depend on the synchronization mode, it can be one of the two type:

-   LIGHT - saved only carcase of blocks.

-   FULL - saved blocks with all inner metadata (transactions, receipts, states).

### Sync Messages

Messages in the pre-init synchronization step:

BlockAvailabilityRequest - message to clarify whether there is a block with a hash.

-   Hash

BlockAvailabilityResponse

-   Hash

-   Height

-   Genesis Block

Messages in the synchronization step:

EpochRequestMessage

-   Epoch Index

-   Sync Mode

EpochResponseMessage

-   Delegate Key

-   Is Epoch Exists

-   Genesis Block

-   List of main block

### Step of synchronization

Synchronization starts when the node gets a block for commit which have:

-   Height is greater than node's last block,

-   Previous Hash is not equal to node's last block hash.

#### Init

-   Set synchronization status to PROCESSING.

-   Request BlockAvailabilityRequest with last block hash to the random last known active delegate, and schedule the request to the next active delegate if the previous one did not respond.

-   Obtain BlockAvailabilityResponse, cancel previous scheduled task.

-   If BlockAvailabilityResponse contains height = -1, it means that it's not a valid epoch and it belongs to remove.

-   All data for this epoch removing.

-   Repeat the step with BlockAvailabilityRequest.

-   Else start synchronization by node's last genesis block.

#### Epoch Synchronization

On this step creates SyncSession depend on SyncMode (FULL or LIGHT) and starts requesting previous epochs.

SyncSession - instance of session, consist of:

-   Sync Mode

-   Last Local Genesis Block

-   Current Genesis Block

-   Epoch Quantity - Count of epoch, which needed download.

-   Storage - temp store for received blocks.

-   Ð¡ompletion flag

-   Epoch Added - Count of epoch added.

Received blocks validate for consistency and are adds to SyncSession.Storage. When received blocks are rejected by validation the session is deleted along with the storage and begins on a new.

After downloads all epochs, they are saved into DB and synchronization status change to SYNCHRONIZED. Synchronization continues until the last actual block in the network is received.

DB checker
----------

DB checker runs before start application and prepare DB for application running.

### Prepare DB

DB checker's function to prepare the database to work. This method takes syncMode parameter. This parameter is necessary to assign node synchronization type. Â Sync mode may have the following values:

-   Light

-   Full

In the case with 'Light' type synchronization db checker validates following block components:

-   Signature

-   Hash

-   Previous hash

-   Timestamp

-   Height

-   Receipts

-   States

In the case with 'Full' type synchronization Â validates block transactions additionally.

### Delete invalid chain part

In the case when the chain has invalid block DB checker removes part of chain from this block to end.

After the validation is complete, the application is started.

Cryptography
============

Cryptography is one of the core aspects of blockchain technology.

Bitcoin Improvement Proposal
----------------------------

### BIP32 (Hierarchical Deterministic Wallets)

OPEN supports HD Wallets generation - wallets which can be shared partially or entirely with different systems, each with or without the ability to spend coins.

HD Wallets contain keys derived in a tree structure, such that a parent key can derive a sequence of children keys, each of which can derive a sequence of grandchildren keys, and so on, to an infinite depth.

According to the BIP32 rules, at each level of the hierarchy, the spawning node has three objects: a private key, a public key and a chain code that is used to generate the next level of a hierarchy.

![](https://docs.google.com/drawings/u/2/d/secPU2mo0xMnUve3n-KV_bw/image?w=624&h=292&rev=3&ac=1&parent=1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs)

Child Key Derivation Function ~ CKD(x,n) = HMAC-SHA512(Xchain, XpublicKey || n)

Derivation path: m / account ' / chain ' / address ', where account, chain, and address are indexes in the path.

The external chain (index = 0) is used to send and receive funds from others (m/0/0/0). The internal chain (index = 1) can be used to generate an address for receiving changes (m/0/1/0).

To divide wallets into groups (e.g. personal, work) the second parameter is used. E.g. m/0/0/0 - personal account, m/1/0/0 - work account

Derivation path of the default account is m/0/0/0

Examples:

Derivation path: m/0/0/0

|

Seed phrase

 |

monkey tissue dream ketchup myth luxury fee plate teach either shadow web

 |
|

Private key

 |

408d2eea0f9acee62d19643822d7084cd9c717a5958fba8b1f63792500a78f9a

 |
|

Public key

 |

03a882e56974a27642f9a97ba9a7936c4cdab86894c9959ef8708fa1f9f7118b1c

 |
|

Wallet address

 |

0xd38f124D7FE13e5693C59e6729B88D482943723C

 |

Derivation path: m/0/0/1

|

Seed phrase

 |

monkey tissue dream ketchup myth luxury fee plate teach either shadow web

 |
|

Private key

 |

0fc23fcf9f035d1dc5823c44cf22e38acab3fe7229251aad2adbd9debda876d9

 |
|

Public key

 |

02277d37802afb983286ca2103d3ee16e8e86b34f000f5364f4c67a25f82d15d2d

 |
|

Wallet address

 |

0x10d32FbBEF1b9A67EE37Da416b187E435dD6CF50

 |

Hierarchical deterministic wallets are described under [BIP32 document](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)

### BIP39 (Mnemonic code for generating deterministic keys)

Mnemonic code or mnemonic sentence is a group of easy to remember words. It could be written on paper or spoken over the telephone.

The mnemonic must encode entropy in a multiple of 32 bits. With more entropy security is improved but the sentence length increases.

Let:

-   ENT - entropy length, bit, Â ENT â [128,256]

-   CS - checksum length, bit

-   MS - mnemonic sentence length, words count

Generating the mnemonic:

1.  Create a random sequence (entropy) of 128 to 256 bits.

2.  Create a checksum by taking the first ENT / 32 bits of its SHA256 hash.

3.  Add the checksum to the end of the random sequence.

4.  Divide the sequence into sections of 11 bits, using those to index a dictionary of 2048 predefined words.

5.  Convert these numbers into words and use the joined words as a mnemonic sentence.

The following table describes the relation between the initial entropy length (ENT), the checksum length (CS) and the length of the generated mnemonic sentence (MS) in words.

|

ENT

 |

CS = ENT / 32

 |

MS = (ENT + CS) / 11

 |
|

128

 |

4

 |

12

 |
|

160

 |

5

 |

15

 |
|

192

 |

6

 |

18

 |
|

224

 |

7

 |

21

 |
|

256

 |

8

 |

24

 |

OPEN uses 12-length mnemonic sentence to generate seed.

From mnemonic to seed:

The mnemonic code represents 128 to 256 bits, which are used to derive a longer (512-bit) seed through the use of the key-stretching function PBKDF2. The resulting seed is used to create a deterministic wallet and all of its derived keys.

Example:

|

Entropy input (128 bits)

 |

0c1e24e5917779d297e14d45f14e1a1a

 |
|

Mnemonic (12 words)

 |

army van defense carry jealous true garbage claim echo media make crunch

 |
|

Seed (512 bits)

 |

3338a6d2ee71c7f28eb5b882159634cd46a898463e9d2d0980f8e80dfbba5b0fa0291e5fb888a599b44b93187be6ee3ab5fd3ead7dd646341b2cdb8d08d13bf7

 |

Mnemonic code generation is described under [BIP39 document](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)

Asymmetric cryptography
-----------------------

Asymmetric cryptography is known as public key cryptography. It allows information to be transferred through a public key that can be shared with anyone. âPublic and private keys both are mathematically related and have a specific role in the operation. Data that is encrypted with a private key can only be decrypted with a public key and vice versa. You cannot encrypt and decrypt data using the same key.\
OPEN uses the Elliptic Curve Digital Signature Algorithm, or ECDSA, which is used to create a public and private key.

![](https://docs.google.com/drawings/u/2/d/sme2m259SmAAyKZ8p6pkVaQ/image?w=497&h=256&rev=2&ac=1&parent=1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs)\
In OPEN asymmetric cryptography is used to produce a digital signature of transactions and blocks.

### Elliptic-curve cryptography

Elliptic curve cryptography is a type of asymmetric cryptography based on the discrete logarithm problem as expressed by addition and multiplication on the points of an elliptic curve.

OPEN uses a specific elliptic curve and set of mathematical constants, as defined in a standard called secp256k1, established by the National Institute of Standards and Technology (NIST). The secp256k1 curve is defined by the following function, which produces an elliptic curve:

y2 mod p = (x3 + 7) mod p

The mod p indicates that this curve is over a finite field of prime order p.

### Private and public keys generation

The private key is randomly generated from a seed phrase.

By multiplying private key by a predetermined point on the curve called the generator point G, another point somewhere else on the curve will be produced. This is the corresponding public key K.

The generator point is specified as part of the secp256k1 standard and is always the same for all keys

Digital signature
-----------------

A digital signature is an encrypted electronic stamp used to authenticate digital data or information and securing sensitive information.

OPEN uses digital signatures to verify the identity of the person sending the transaction or block.

### Signing transaction

To sign a transaction a sender encrypts transaction bytes with his private key. The sender includes his public key and the resulting signature in the transaction.

Transaction bytes include:

-   Timestamp

-   Sender address

-   Fee

-   Amount

-   Recipient address (transfer transaction)

-   Delegate Key (delegate and vote transaction)

-   Vote type (vote transaction)

![](https://docs.google.com/drawings/u/2/d/sf0BaNnRiwHW-S6AyLHE-AQ/image?w=643&h=254&rev=134&ac=1&parent=1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs)

### Signing Block

To sign a main block active delegate encrypts block bytes with his node's private key. Since a genesis block is generated by each peer independently, the peer uses his node's private key to encrypt the block.\
The signer includes the public key of his node and the resulting signature in the block.

Main block bytes include:

-   Timestamp

-   Block height

-   Previous block height

-   Transactions Merkle Hash

-   States Merkle Hash

-   Receipts Merkle Hash

Genesis block bytes include:

-   Timestamp

-   Block height

-   Previous block height

-   Active delegates' public keys

-   Epoch index

![](https://docs.google.com/drawings/u/2/d/s8k02RihtpYQueBqROvFAqg/image?w=492&h=326&rev=179&ac=1&parent=1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs)

Hash Functions
--------------

Hashing is the process of taking the input of any length and turning it into a cryptographic fixed output through a mathematical algorithm.

OPEN uses different types of hash functions for different purposes.\
SHA256 is one of the strongest hash functions available. In OPEN it is used to generate transaction hash, block hash, state, and receipt hash by hashing their bytes. The resulting hash is 265-bit long.

Keccak256 is another hash function used by OPEN. Wallet address is a keccak256 hash of the public key.

PBKDF2 is a key-stretching function with a sliding computational cost, aimed to reduce the vulnerability of encrypted keys to brute force attacks. PBKDF2 hash is used to generate a seed from a mnemonic sentence.

HMAC is a specific type of message authentication code (MAC) involving a cryptographic hash function and a secret cryptographic key. HMACSHA512 function is used in the key derivation algorithm described in BIP32.

RIPEMD160SHA256 is also used for key derivation. This function presents a combination of RIPEMD160 and SHA256 hashes. RIPEMD160 was used because it produces the shortest hashes whose uniqueness is still sufficiently assured.

Merkle Root
-----------

Merkle trees provide a cryptographically authenticated data structure. A Merkle tree is a tree structure in which each leaf node is a hash of a block of data and each non-leaf node is a hash of its children. This results in a single hash called the Merkle root.

![](https://docs.google.com/drawings/u/2/d/spMh7diQViqkg-c3M8IKc7Q/image?w=631&h=339&rev=214&ac=1&parent=1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs)

Each OPEN main block has the transaction Merkle root, states Merkle root and receipt Merkle root. Using a Merkle tree provides the integrity and validity of transactions, states and receipts using their hashes that an active delegate has to maintain.

If an attacker changes any parameter in the transaction of the block, transaction Merkle root will change along with the nodes of the Merkle tree. The active delegate will consider this main block invalid.

![](https://docs.google.com/drawings/u/2/d/sV4wFuhqJOQV7-qgi40rVgA/image?w=624&h=335&rev=15&ac=1&parent=1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs)

Network
=======

Serialization protocol
----------------------

OPEN Chain nodes communicate via TCP transport protocol, exchanging messages in a specific format. Conventionally, message is divided into two parts:

-   Message header

-   Message body

### Message header

Each message strictly contain 3 fields:

-   Version - indicates protocol version. If nodes protocol version is not equal to one specified in header, message will be ignored

-   Time - timestamp, when message was sent. There is an expiry period, 10 seconds, when message considered as actual. If it is transmitted more than expiry period, message is Ñgnored

-   Message Type - indicates type of message

### Message body

Message body contains all required fields to create an instance and handle it by node. Field is decoded, according to it's Â type. Type of field tells about amount of bytes, which have to be readed and stored. Below is the list of primitive types and their amount of bytes, which should be readed:

-   Byte - 1 byte

-   Short - 2 byte

-   Integer - 4 byte

-   Long - 8 byte

-   Float - 4 byte

-   Double - 8 byte

-   Boolean - 1 byte

-   Character - 2 byte

Protocol allows to serialize string data type. To perform that, there should be an Integer value serialized before set of characters, describing the string's length. The same approach is applied to collections: the amount of elements should be serialized before the actual content

Gossip Protocol
---------------

Gossip protocol describes approach, how communication is performed in peer-to-peer network. Suppose we got peer, connected to other nodes. It sends message to each peer. In OPEN Chain node should obtain at least 4 connections to operate in network (maximum number of connections is 16). Peers, that recieved message, handle it and pass further to network. And that is how message is broadcasted to network. Message won't be passed further in two cases:

-   Node, accepted message, had already such message in the past

-   Message will be ignored, because of it's expiration

![](https://docs.google.com/drawings/u/2/d/sEWZefpnHGsZYVUZEts4pCw/image?w=624&h=293&rev=2&ac=1&parent=1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs)

![](https://docs.google.com/drawings/u/2/d/sD9s6q0eXUIiVVECOhq3Jlg/image?w=624&h=293&rev=2&ac=1&parent=1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs)

Time Synchronisation
--------------------

For the application to work properly, a synchronized system clock with an accuracy of 100 milliseconds is required.

On start up application ClockChecker requests time offset from the NTP servers, with a certain time interval. If received the offset is in valid values, the application runs in normal mode, else the time is not synchronized state, the application will require to set the correct time. Otherwise, normal operation is not guaranteed.

Smart Contract
==============

Smart contracts are account holding objects on the Open Platform blockchain. They contain code functions, make decisions, store data, and send ether to others. Contracts are defined by their creators, but their execution, and by extension the services they offer, is provided by the Open Platform network itself. They will exist and be executable as long as the whole network exists, and will only disappear if they were programmed to self destruct.

What can you do with contracts? You can transfer money other wallets. Save various information and interaction with it. But for our getting started guide let's do some simple things: To start you will create a classic "Hello World" contract, then you can build your own crypto token to send to whomever you like.

Creation
--------

Before you begin:

1.  Prepare any jvm environment

2.  Your patience and curiosity

### Writing a contract

Any own smart contract must extend superclass "SmartContract", which has an abstract method "execute".

The example will be in Kotlin:

|

class HelloWorld : SmartContract() {

Â Â Â override fun execute() {

Â Â Â Â Â Â Â println("Hello world")

Â Â Â }

}

 |

Then you need to compile the class and get bytecode.

Validation
----------

Before uploading smart contract to blockchain the Node  validate it on a number of restrictions.

You can validate it itself. In order to do it, there is a special class "SmartContractValidator", which has a method "validate". This method will return true if bytecode is right and false if not.

This method checks by the following criteria:

|

Â Â Â Â Â Â Â Boolean::class.java.name,\
Â Â Â Â Â Â Â Char::class.java.name,\
Â Â Â Â Â Â Â Byte::class.java.name,\
Â Â Â Â Â Â Â Short::class.java.name,\
Â Â Â Â Â Â Â Int::class.java.name,\
Â Â Â Â Â Â Â Long::class.java.name,\
Â Â Â Â Â Â Â Float::class.java.name,\
Â Â Â Â Â Â Â Double::class.java.name,\
Â Â Â Â Â Â Â Void::class.javaPrimitiveType!!.name,

Â Â Â Â Â Â Â "java.lang.Boolean",\
Â Â Â Â Â Â Â "java.lang.Character",\
Â Â Â Â Â Â Â "java.lang.Byte",\
Â Â Â Â Â Â Â "java.lang.Short",\
Â Â Â Â Â Â Â "java.lang.Integer",\
Â Â Â Â Â Â Â "java.lang.Long",\
Â Â Â Â Â Â Â "java.lang.Float",\
Â Â Â Â Â Â Â "java.lang.Double",\
Â Â Â Â Â Â Â "java.lang.String",\
Â Â Â Â Â Â Â "java.lang.StringBuilder",\
Â Â Â Â Â Â Â "java.lang.StrictMath",

Â Â Â Â Â Â Â "java.util.ArrayList",\
Â Â Â Â Â Â Â "java.util.Arrays",\
Â Â Â Â Â Â Â "java.util.HashMap",\
Â Â Â Â Â Â Â "java.util.HashSet"

 |

There is a blacklist of the methods Object class in order to restrict stop a smart contract.

|

Â Â Â Â Â Â Â "java.lang.Object.getClass",\
Â Â Â Â Â Â Â "java.lang.Object.wait",\
Â Â Â Â Â Â Â "java.lang.Object.notify",\
Â Â Â Â Â Â Â "java.lang.Object.notifyAll"

 |

Evaluation
----------

The cost of the contract is estimated during the deployment phase. The estimate is based on bytecode, each opcode has its own cost.

Ð¡alculation formula

contractCost = (countOpcodem*costOpcodem)+...+(countOpcodem+n*costOpcodem+n)

Loading
-------

After all the checks we can begin uploading a smart contract in the blockchain. All you need is to insert a ready-made bytecode in the field of Node in the browser and send a transfer transaction.

Under the hood, everything is a little more complicated. Before you save it to the blockchain this smart contract name is changed in order to it was unique in JVM. Then the Node upload it in JVM and initialize object default data. After this, the Node serializes state and send to the blockchain.

Execution
---------

The execution of the contract is triggered when funds are received in the account of the contract. You can do this by sending a transfer transaction by specifying the address of the contract in the recipients.

Step of execution

1.  Searching and loading contract by his specific address from DB into JVM.

2.  Creating the instance of contract and initialization inner state.

3.  Execution.

1.  Doing some of the things that are written in it. For example: creating transfer transactions to specific address.

5.  Saving execution results and transfer of funds to the delegate for execution.

1.  Saving all transfer actions in DB like Receipts.

2.  If the contract fails, then saves the cause of error in Receipt.

7.  Serializing inner state into DB if contract successfully end.

8.  Transfer odd money after execution back to sender`s wallet.

1.  If the contract`s wallet amount is not spent in full, it remains on the contract account.

State Synchronisation
---------------------

Contract has inner state such like variables, it's all stored in serialized form in the DB.

Before the contract will execute, its state loads from DB and push into the instance.

After successfully ending inner state of the contract serializes and stores in DB for the next executions. When execution fails, the state does not change.

Remote Procedure Call
=====================

RPC is using to call REST-endpoints.

|

endpoint

 |

Description

 |

Explorer

 |

Wallet Client

 |
|

[/rpc/info](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.f2l78m6i26ay)

 |

Get basic node information.

 |

+

 |\
 |
|

[/rpc/info/getVersion](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.kke78hlqnc9l)

 |

Get node communication protocol version.

 |

+

 |\
 |
|

[/rpc/info/getUptime](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.buow7oyq8262)

 |

Get node up time.

 |

+

 |\
 |
|

[/rpc/info/getHardwareInfo](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.3oqucrw4v9gz)

 |

Get node hardware info: CPU and RAM info, total storage size and network interfaces info.

 |

+

 |\
 |
|

[/rpc/explorer/info](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.aw7smql1lwpf)

 |

Gets information about blockchain

 |

+

 |\
 |
|

[/rpc/account/doGenerate](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.5f5sn3g59mta)

 |

Generate new account

 |\
 |

+

 |
|

[/rpc/account/doRespore](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.yjurh4p8x83s)

 |

Restore an account by seed phrase

 |\
 |

+

 |
|

[/rpc/accounts/wallets/{address}/balance](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.sg0mxgk1xoin)

 |

Get wallet balance by wallet address

 |\
 |

+

 |
|

[/rpc/accounts/wallets/{address}/delegates](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.2ta2ndh08qew)

 |

Get wallet votes for delegates

 |\
 |

+

 |
|

[/rpc/accounts/wallets/validateAddress](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.rqkabzhv7ja5)

 |

Validate wallet address

 |\
 |

+

 |
|

[/rpc/account/keys/doDerive](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.22oxvw2u1bqh)

 |

Creates new account by derivation path.

 |\
 |

+

 |
|

[/rpc/accounts/keys/doPrivateImport](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.gefgmqyltewd)

 |

Gets public key and wallet address for private key.

 |\
 |

+

 |
|

[/rpc/accounts/keys/doExtendedImport](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.a0c7ey8do4oq)

 |

Restores an account by private or public extended key.

 |\
 |

+

 |
|

[/rpc/accounts/keys/doWifImport](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.m1o7oi8filtu)

 |

Restore an account by private key in WIF (Wallet import format) format.

 |\
 |

+

 |
|

[/rpc/blocks/genesis](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.fb5fzm1umgz)

 |

Gets list of all genesis blocks

 |\
 |

+

 |
|

[/rpc/blocks/genesis/{hash}](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.yqb4ej9ddee5)

 |

Gets genesis block by hash

 |\
 |

+

 |
|

[/rpc/blocks/genesis/{hash}/previous](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.4cu599idzg01)

 |

Gets previous genesis block by hash

 |\
 |

+

 |
|

[/rpc/blocks/genesis/{hash}/next](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.3zrnf7pflq8a)

 |

Gets next genesis block by hash

 |\
 |

+

 |
|

[/rpc/blocks/main](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.bcb6maoehikv)

 |

Gets list of all main blocks

 |\
 |

+

 |
|

[/rpc/blocks/main/{hash}](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.la11qqb1haez)

 |

Gets main block by hash

 |\
 |

+

 |
|

[/rpc/blocks/main/{hash}/previous](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.r2gefc20hob0)

 |

Gets previous main block by hash

 |\
 |

+

 |
|

[/rpc/blocks/main/{hash}/next](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.4jojidvgk1q7)

 |

Get next main block by hash

 |\
 |

+

 |
|

[/rpc/transactions/delegate](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.8tbmna8mh3rk)

 |

Send delegate transaction

 |\
 |

+

 |
|

[/rpc/transactions/delegate/{hash}](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.210g2teh2lqo)

 |

Gets delegate transaction by hash

 |\
 |

+

 |
|

[/rpc/transactions/reward](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.edw9tv1ia2d)

 |

Gets list of all reward transactions

 |\
 |

+

 |
|

[/rpc/transactions/reward/{address}](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.w45alae18qso)

 |

Gets reward transaction by recipient address

 |\
 |

+

 |
|

[/rpc/transactions/transfer](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.7ar8ydc5x4oy)

 |

Gets list of transfer transaction

 |\
 |

+

 |
|

[/rpc/transactions/transfer](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.jqtja24gn0m9)

 |

Send transfer transaction

 |\
 |

+

 |
|

[/rpc/transactions/transfer/{hash}](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.qj8vpkvy3ao5)

 |

Gets transfer transaction by hash

 |\
 |

+

 |
|

[/rpc/transactions/transfer/address/{address}](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.m51ssq4lvbgo)

 |

Gets transfer transaction by wallet address

 |\
 |

+

 |
|

[/rpc/transactions/vote](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.80l00atsbdqi)

 |

Send vote transaction

 |\
 |

+

 |
|

[/rpc/transactions/vote/{hash}](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.6xpl9iice6fp)

 |

Gets vote transaction by hash

 |\
 |

+

 |
|

[/rpc/delegates](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.u723l86nc594)

 |

Gets list of all delegates

 |\
 |

+

 |
|

[/rpc/delegates/active](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.m3b002niq57z)

 |

Gets list of all active delegates

 |\
 |

+

 |
|

[/rpc/delegates/view](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.cya2szvgdcy2)

 |

Gets list of all delegates rating

 |\
 |

+

 |
|

[/rpc/transactions/{hash}/receipt](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.2pxu3fkhlmca)

 |

Gets receipt by hash of the transaction

 |\
 |

+

 |
|

[/rpc/contracts/estimation](https://docs.google.com/document/d/1VoOUFPkgdHxetaEC2oxQkByP_iGfMy949EQef7TFcVs/edit#heading=h.onupms4lbi3t)

 |

Gets cost of execution/deployment of the contract

 |\
 |

+

 |

This REST-endpoints are using to get current information about the efficiency of the node.

Get info
--------

Get basic node information.

HTTP method: GET

Path: /rpc/info

Parameters: None

Response:

|

{

Â Â Â "timestamp": 1533201403476,

Â Â Â "version": "1.0.0",

Â Â Â "payload": {

Â Â Â Â Â Â Â "publicKey": "02a54008f5deea06a1bd9ec995ff458d6ffa235ba40be48034a8fab6873c805bfa",

Â Â Â Â Â Â Â "host": "127.0.0.1",

Â Â Â Â Â Â Â "port": 9190

Â Â Â }

}

 |

Response fields:

|

Attribute

 |

Type

 |

Description

 |
|

publicKey

 |

String

 |

Node's public key

 |
|

host

 |

String

 |

Node's external host

 |
|

port

 |

String

 |

Node's external port

 |

Get version
-----------

Get node communication protocol version.

Type: GET

Path: /rpc/info/getVersion

Parameters: None

Response:

|

{

Â Â Â "timestamp": 1533201403476,

Â Â Â "version": "1.0.0",

Â Â Â "payload": null

}\
 |

Get uptime
----------

Get node up time.

Type: GET

Path: /rpc/info/getUptime

Parameters: None

Response:

|

{

Â Â Â "timestamp": 1533201463165,

Â Â Â "version": "1.0.0",

Â Â Â "payload": 4007529

}

 |

Response fields:

|

Attribute

 |

Type

 |

Description

 |
|

payload

 |

Long

 |

Node up time in millis

### License

The OPEN Platform project is licensed under the [MIT license](./LICENSE.txt).
